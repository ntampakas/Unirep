"use strict";(self.webpackChunk_unirep_docs=self.webpackChunk_unirep_docs||[]).push([[607],{30876:(e,t,o)=>{o.d(t,{Zo:()=>s,kt:()=>k});var n=o(2784);function i(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function r(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function a(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?r(Object(o),!0).forEach((function(t){i(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):r(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function l(e,t){if(null==e)return{};var o,n,i=function(e,t){if(null==e)return{};var o,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)o=r[n],t.indexOf(o)>=0||(i[o]=e[o]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)o=r[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(i[o]=e[o])}return i}var c=n.createContext({}),p=function(e){var t=n.useContext(c),o=t;return e&&(o="function"==typeof e?e(t):a(a({},t),e)),o},s=function(e){var t=p(e.components);return n.createElement(c.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var o=e.components,i=e.mdxType,r=e.originalType,c=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),u=p(o),d=i,k=u["".concat(c,".").concat(d)]||u[d]||h[d]||r;return o?n.createElement(k,a(a({ref:t},s),{},{components:o})):n.createElement(k,a({ref:t},s))}));function k(e,t){var o=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=o.length,a=new Array(r);a[0]=d;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[u]="string"==typeof e?e:i,a[1]=l;for(var p=2;p<r;p++)a[p]=o[p];return n.createElement.apply(null,a)}return n.createElement.apply(null,o)}d.displayName="MDXCreateElement"},64306:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var n=o(7896),i=(o(2784),o(30876));const r={description:"The zero-knowledge circuit of epoch key proof in UniRep"},a="Epoch Key Proof",l={unversionedId:"protocol/circuits/epoch-key-proof",id:"version-1.0.1/protocol/circuits/epoch-key-proof",title:"Epoch Key Proof",description:"The zero-knowledge circuit of epoch key proof in UniRep",source:"@site/versioned_docs/version-1.0.1/protocol/circuits/epoch-key-proof.md",sourceDirName:"protocol/circuits",slug:"/protocol/circuits/epoch-key-proof",permalink:"/docs/1.0.1/protocol/circuits/epoch-key-proof",draft:!1,editUrl:"https://github.com/Unirep/Unirep/tree/main/packages/docs/versioned_docs/version-1.0.1/protocol/circuits/epoch-key-proof.md",tags:[],version:"1.0.1",frontMatter:{description:"The zero-knowledge circuit of epoch key proof in UniRep"},sidebar:"apiSidebar",previous:{title:"Users and Attesters",permalink:"/docs/1.0.1/protocol/glossary/users-and-attesters"},next:{title:"Reputation Proof",permalink:"/docs/1.0.1/protocol/circuits/reputation-proof"}},c={},p=[{value:"Public inputs",id:"public-inputs",level:2},{value:"Public outputs",id:"public-outputs",level:2},{value:"Private inputs",id:"private-inputs",level:2},{value:"Contraints",id:"contraints",level:2},{value:"1. Check if user exists in the Global State Tree",id:"1-check-if-user-exists-in-the-global-state-tree",level:3},{value:"2. Check nonce validity",id:"2-check-nonce-validity",level:3},{value:"3. Check epoch key is computed correctly",id:"3-check-epoch-key-is-computed-correctly",level:3}],s={toc:p},u="wrapper";function h(e){let{components:t,...o}=e;return(0,i.kt)(u,(0,n.Z)({},s,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"epoch-key-proof"},"Epoch Key Proof"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/docs/1.0.1/protocol/glossary/epoch-key"},"Epoch key")," is computed by"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"hash2([\n    identityNullifier + nonce,\n    epoch\n]) % BigInt(2 ** epochTreeDepth)\n")),(0,i.kt)("p",null,"The epoch key proof in UniRep is used to prove that"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The epoch key is in the epoch that user claims."),(0,i.kt)("li",{parentName:"ol"},"The epoch key nonce is between ",(0,i.kt)("inlineCode",{parentName:"li"},"0")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"numEpochKeyNoncePerEpoch - 1"),"."),(0,i.kt)("li",{parentName:"ol"},"The owner of the epoch key has ",(0,i.kt)("a",{parentName:"li",href:"../glossary/users-and-attesters#user"},"registered")," in UniRep and has performed the ",(0,i.kt)("a",{parentName:"li",href:"/docs/1.0.1/protocol/glossary/user-state-transition"},"user state transition")," in the latest epoch. In other words, the user has a leaf in the global state tree.")),(0,i.kt)("h2",{id:"public-inputs"},"Public inputs"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"epoch"),": the claimed epoch that the epoch key is in")),(0,i.kt)("h2",{id:"public-outputs"},"Public outputs"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"epoch_key"),": the claimed epoch key"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"GST_root"),": the global state tree root that the user has a leaf in")),(0,i.kt)("h2",{id:"private-inputs"},"Private inputs"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nonce"),": the nonce of epoch key. It should be in range ",(0,i.kt)("inlineCode",{parentName:"li"},"[0, numEpochKeyNoncePerEpoch)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"identity_nullifier"),": the identity that the Semaphore protocol uses, and it is also used to generate an epoch key."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"identity_trapdoor"),": the identity trapdoor key that the Semaphore protocol uses. The hash output of ",(0,i.kt)("inlineCode",{parentName:"li"},"identity_nullifier"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"identity_trapdoor")," is the ",(0,i.kt)("inlineCode",{parentName:"li"},"identity_commitment")," and it is used to generate a global state tree leaf by")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const GST_leaf = hash(identity_commitment, UST_root)\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"user_tree_root"),": the user state tree root. It is used to compute the global state tree leaf"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"GST_path_index"),": the path index routes from leaf to root in the global state tree. It should be either ",(0,i.kt)("inlineCode",{parentName:"li"},"0")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"1")," to indicate if the element is in the right sibling or the left sibling."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"GST_path_elements"),": The sibling node that should be hashed with current path element to get the root.")),(0,i.kt)("h2",{id:"contraints"},"Contraints"),(0,i.kt)("h3",{id:"1-check-if-user-exists-in-the-global-state-tree"},"1. Check if user exists in the Global State Tree"),(0,i.kt)("p",null,"Check if ",(0,i.kt)("inlineCode",{parentName:"p"},"hash(identity_commitment, UST_root)")," is one of the leaves in the global state tree of root ",(0,i.kt)("inlineCode",{parentName:"p"},"GST_root"),"."),(0,i.kt)("h3",{id:"2-check-nonce-validity"},"2. Check nonce validity"),(0,i.kt)("p",null,"Check if ",(0,i.kt)("inlineCode",{parentName:"p"},"nonce < EPOCH_KEY_NUM_PER_EPOCH")),(0,i.kt)("h3",{id:"3-check-epoch-key-is-computed-correctly"},"3. Check epoch key is computed correctly"),(0,i.kt)("p",null,"Check if ",(0,i.kt)("inlineCode",{parentName:"p"},"epoch_key = hash2([identityNullifier + nonce, epoch]) % BigInt(2 ** epochTreeDepth)")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"See the whole circuit in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Unirep/Unirep/blob/v1.0.1/packages/circuits/circuits/verifyEpochKey.circom"},"circuits/verifyEpochKey.circom"))))}h.isMDXComponent=!0}}]);