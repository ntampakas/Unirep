"use strict";(self.webpackChunk_unirep_docs=self.webpackChunk_unirep_docs||[]).push([[1711],{30876:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(2784);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=p(n),h=r,m=c["".concat(s,".").concat(h)]||c[h]||d[h]||i;return n?a.createElement(m,o(o({ref:t},u),{},{components:n})):a.createElement(m,o({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},39029:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=n(7896),r=(n(2784),n(30876));const i={title:"Unirep.sol"},o=void 0,l={unversionedId:"contracts-api/unirep-sol",id:"version-2.1.x/contracts-api/unirep-sol",title:"Unirep.sol",description:"This is the core UniRep contract.",source:"@site/versioned_docs/version-2.1.x/contracts-api/unirep-sol.md",sourceDirName:"contracts-api",slug:"/contracts-api/unirep-sol",permalink:"/docs/contracts-api/unirep-sol",draft:!1,editUrl:"https://github.com/Unirep/Unirep/tree/main/packages/docs/versioned_docs/version-2.1.x/contracts-api/unirep-sol.md",tags:[],version:"2.1.x",frontMatter:{title:"Unirep.sol"},sidebar:"apiSidebar",previous:{title:"IUnirep.sol",permalink:"/docs/contracts-api/iunirep-sol"},next:{title:"Example: UniRep Voting contract",permalink:"/docs/contracts-api/unirep-voting-sol"}},s={},p=[{value:"config",id:"config",level:2},{value:"userSignUp",id:"usersignup",level:2},{value:"manualUserSignUp",id:"manualusersignup",level:2},{value:"attesterSignUp",id:"attestersignup",level:2},{value:"attesterSignUpViaRelayer",id:"attestersignupviarelayer",level:2},{value:"attest",id:"attest",level:2},{value:"userStateTransition",id:"userstatetransition",level:2},{value:"updateEpochIfNeeded",id:"updateepochifneeded",level:2},{value:"decodeSignupControl",id:"decodesignupcontrol",level:2},{value:"decodeSignupSignals",id:"decodesignupsignals",level:2},{value:"decodeUserStateTransitionControl",id:"decodeuserstatetransitioncontrol",level:2},{value:"decodeUserStateTransitionSignals",id:"decodeuserstatetransitionsignals",level:2},{value:"attesterCurrentEpoch",id:"attestercurrentepoch",level:2},{value:"attesterEpochRemainingTime",id:"attesterepochremainingtime",level:2},{value:"signupVerifier",id:"signupverifier",level:2},{value:"userStateTransitionVerifier",id:"userstatetransitionverifier",level:2},{value:"attesterStartTimestamp",id:"attesterstarttimestamp",level:2},{value:"attesterEpochLength",id:"attesterepochlength",level:2},{value:"attesterStateTreeRootExists",id:"attesterstatetreerootexists",level:2},{value:"attesterStateTreeRoot",id:"attesterstatetreeroot",level:2},{value:"attesterStateTreeLeafCount",id:"attesterstatetreeleafcount",level:2},{value:"attesterSemaphoreGroupRoot",id:"attestersemaphoregrouproot",level:2},{value:"attesterMemberCount",id:"attestermembercount",level:2},{value:"attesterEpochRoot",id:"attesterepochroot",level:2},{value:"stateTreeDepth",id:"statetreedepth",level:2},{value:"epochTreeDepth",id:"epochtreedepth",level:2},{value:"historyTreeDepth",id:"historytreedepth",level:2},{value:"numEpochKeyNoncePerEpoch",id:"numepochkeynonceperepoch",level:2},{value:"fieldCount",id:"fieldcount",level:2},{value:"sumFieldCount",id:"sumfieldcount",level:2},{value:"replNonceBits",id:"replnoncebits",level:2},{value:"replFieldBits",id:"replfieldbits",level:2},{value:"chainid",id:"chainid",level:2},{value:"defaultDataHash",id:"defaultdatahash",level:2},{value:"attestationCount",id:"attestationcount",level:2}],u={toc:p},c="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(c,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This is the core UniRep contract."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"import { Unirep } from '@unirep/contracts/Unirep.sol';\n")),(0,r.kt)("h2",{id:"config"},"config"),(0,r.kt)("p",null,"The config that is set in UniRep."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function config() public view returns (Config memory)\n")),(0,r.kt)("h2",{id:"usersignup"},"userSignUp"),(0,r.kt)("p",null,"Submit a signup zk proof for a user."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("inlineCode",{parentName:"p"},"msg.sender")," must be the attester.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function userSignUp(\n  uint[] calldata publicSignals,\n  uint[8] calldata proof\n) public\n")),(0,r.kt)("h2",{id:"manualusersignup"},"manualUserSignUp"),(0,r.kt)("p",null,"Sign up a new user by manually supplying an identity commitment and an ",(0,r.kt)("a",{parentName:"p",href:"/docs/utils-api/modules#genidentityhash"},"identity hash"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"initialData")," should be the values of the user data in the state tree leaf (if non-zero). This is designed to be used by applications that want custom signup proofs."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("inlineCode",{parentName:"p"},"msg.sender")," must be the attester.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function manualUserSignUp(\n  uint48 epoch,\n  uint256 identityCommitment,\n  uint256 leafIdentityHash,\n  uint256[] calldata initialData\n) public\n")),(0,r.kt)("h2",{id:"attestersignup"},"attesterSignUp"),(0,r.kt)("p",null,"Register an attester contract. ",(0,r.kt)("inlineCode",{parentName:"p"},"msg.sender")," will become an attester."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"attesterId")," is the address of the attester contract. In this case ",(0,r.kt)("inlineCode",{parentName:"p"},"msg.sender"),".")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function attesterSignUp(uint48 epochLength) public\n")),(0,r.kt)("h2",{id:"attestersignupviarelayer"},"attesterSignUpViaRelayer"),(0,r.kt)("p",null,"Register an attester contract through a relayer. The signature will be recovered and checked if it matches the given ",(0,r.kt)("inlineCode",{parentName:"p"},"attester")," address."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function attesterSignUpViaRelayer(\n  address attester,\n  uint48 epochLength,\n  bytes calldata signature\n) public\n")),(0,r.kt)("h2",{id:"attest"},"attest"),(0,r.kt)("p",null,"Create an attestation to an epoch key. If the current epoch is not the same as ",(0,r.kt)("inlineCode",{parentName:"p"},"epoch")," the transaction will revert."),(0,r.kt)("p",null,"Apply a change to a user data field at index ",(0,r.kt)("inlineCode",{parentName:"p"},"fieldIndex"),". Changes will be applied using either addition or replacement, depending on which field is selected."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("inlineCode",{parentName:"p"},"msg.sender")," must be the attester.")),(0,r.kt)("admonition",{type:"danger"},(0,r.kt)("p",{parentName:"admonition"},"It is expected that the attester will validate an epoch key before performing an attestation. ",(0,r.kt)("br",null),"\nTo check the validity of an epoch key: ",(0,r.kt)("br",null)),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/circuits-api/circuits#epoch-key-proof"},"Epoch key proof")," should be valid. (See ",(0,r.kt)("a",{parentName:"li",href:"/docs/contracts-api/verifiers/epoch-key-verifier-helper"},(0,r.kt)("inlineCode",{parentName:"a"},"EpochKeyVerifierHelper")),"). ",(0,r.kt)("br",null)),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/protocol/trees#state-tree"},"State tree root")," should exist. (See ",(0,r.kt)("a",{parentName:"li",href:"#attesterstatetreerootexists"},(0,r.kt)("inlineCode",{parentName:"a"},"attesterStateTreeRootExists")),") ",(0,r.kt)("br",null)),(0,r.kt)("li",{parentName:"ul"},"Epoch should match the current epoch (See: ",(0,r.kt)("a",{parentName:"li",href:"#attestercurrentepoch"},(0,r.kt)("inlineCode",{parentName:"a"},"attesterCurrentEpoch")),") ",(0,r.kt)("br",null))),(0,r.kt)("p",{parentName:"admonition"},"All of these must be verified to confirm epoch key validity. Attestations may be lost if these are not verified.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function attest(\n  uint epochKey,\n  uint48 epoch,\n  uint fieldIndex,\n  uint change\n) public\n")),(0,r.kt)("h2",{id:"userstatetransition"},"userStateTransition"),(0,r.kt)("p",null,"Execute a user state transition using a ZK proof. This will insert a new state tree leaf in the current epoch."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function userStateTransition(\n  uint[] calldata publicSignals,\n  uint[8] calldata proof\n) public\n")),(0,r.kt)("h2",{id:"updateepochifneeded"},"updateEpochIfNeeded"),(0,r.kt)("p",null,"Update the current epoch if an epoch is over."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function updateEpochIfNeeded(\n  uint160 attesterId\n) public returns (uint48 epoch)\n")),(0,r.kt)("h2",{id:"decodesignupcontrol"},"decodeSignupControl"),(0,r.kt)("p",null,"Decode the control signal of ",(0,r.kt)("a",{parentName:"p",href:"/docs/circuits-api/classes/src.SignupProof"},"signup proof")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function decodeSignupControl(\n  uint256 control\n) public pure returns (\n  uint160 attesterId,\n  uint48 epoch,\n  uint48 chainId\n)\n")),(0,r.kt)("h2",{id:"decodesignupsignals"},"decodeSignupSignals"),(0,r.kt)("p",null,"Decode all public signals of ",(0,r.kt)("a",{parentName:"p",href:"/docs/circuits-api/classes/src.SignupProof"},"signup proof")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function decodeSignupSignals(\n  uint256[] calldata publicSignals\n) public pure returns (SignupSignals memory)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"struct SignupSignals {\n  uint256 stateTreeLeaf;\n  uint48 epoch;\n  uint160 attesterId;\n  uint256 identityCommitment;\n}\n")),(0,r.kt)("h2",{id:"decodeuserstatetransitioncontrol"},"decodeUserStateTransitionControl"),(0,r.kt)("p",null,"Decode the control signal of ",(0,r.kt)("a",{parentName:"p",href:"/docs/circuits-api/classes/src.UserStateTransitionProof"},"user state transition proof")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function decodeUserStateTransitionControl(\n  uint256 control\n) public pure returns (\n  uint160 attesterId, \n  uint48 toEpoch\n)\n")),(0,r.kt)("h2",{id:"decodeuserstatetransitionsignals"},"decodeUserStateTransitionSignals"),(0,r.kt)("p",null,"Decode all public signals of ",(0,r.kt)("a",{parentName:"p",href:"/docs/circuits-api/classes/src.UserStateTransitionProof"},"user state transition proof")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function decodeUserStateTransitionSignals(\n  uint256[] calldata publicSignals\n) public pure returns (UserStateTransitionSignals memory)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"struct UserStateTransitionSignals {\n  uint256 historyTreeRoot;\n  uint256 stateTreeLeaf;\n  uint48 toEpoch;\n  uint160 attesterId;\n  uint256[] epochKeys;\n}\n")),(0,r.kt)("h2",{id:"attestercurrentepoch"},"attesterCurrentEpoch"),(0,r.kt)("p",null,"Get the current epoch number for an attester."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function attesterCurrentEpoch(\n  uint160 attesterId\n) public view returns (uint48)\n")),(0,r.kt)("h2",{id:"attesterepochremainingtime"},"attesterEpochRemainingTime"),(0,r.kt)("p",null,"Get the remaining time, in seconds, for the current epoch for an attester."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function attesterEpochRemainingTime(\n  uint160 attesterId\n) public view returns (uint48)\n")),(0,r.kt)("h2",{id:"signupverifier"},"signupVerifier"),(0,r.kt)("p",null,"A contract address for a signup proof verifier. See ",(0,r.kt)("a",{parentName:"p",href:"verifiers/iverifier-sol"},"IVerifier")," for more info."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"IVerifier public immutable signupVerifier;\n")),(0,r.kt)("h2",{id:"userstatetransitionverifier"},"userStateTransitionVerifier"),(0,r.kt)("p",null,"A contract address for a user state transition proof verifier. See ",(0,r.kt)("a",{parentName:"p",href:"verifiers/iverifier-sol"},"IVerifier")," for more info."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"IVerifier public immutable userStateTransitionVerifier;\n")),(0,r.kt)("h2",{id:"attesterstarttimestamp"},"attesterStartTimestamp"),(0,r.kt)("p",null,"Get the start timestamp for an attester (in seconds). This is the start of the 0th epoch."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function attesterStartTimestamp(uint160 attesterId)\n  public\n  view\n  returns (uint256)\n")),(0,r.kt)("h2",{id:"attesterepochlength"},"attesterEpochLength"),(0,r.kt)("p",null,"Get the epoch length for an attester."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function attesterEpochLength(uint160 attesterId)\n  public\n  view\n  returns (uint48)\n")),(0,r.kt)("h2",{id:"attesterstatetreerootexists"},"attesterStateTreeRootExists"),(0,r.kt)("p",null,"Check if a state tree root exists for an attester and epoch."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function attesterStateTreeRootExists(\n  uint160 attesterId,\n  uint48 epoch,\n  uint256 root\n) public view returns (bool)\n")),(0,r.kt)("h2",{id:"attesterstatetreeroot"},"attesterStateTreeRoot"),(0,r.kt)("p",null,"Get the state tree root for an attester for the current epoch."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function attesterStateTreeRoot(uint160 attesterId)\n  public\n  view\n  returns (uint256)\n")),(0,r.kt)("h2",{id:"attesterstatetreeleafcount"},"attesterStateTreeLeafCount"),(0,r.kt)("p",null,"Get the number of state tree leaves for an attester for the current epoch."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function attesterStateTreeLeafCount(uint160 attesterId)\n  public\n  view\n  returns (uint256)\n")),(0,r.kt)("h2",{id:"attestersemaphoregrouproot"},"attesterSemaphoreGroupRoot"),(0,r.kt)("p",null,"Get the Semaphore group root for an attester."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function attesterSemaphoreGroupRoot(uint160 attesterId)\n  public\n  view\n  returns (uint256)\n")),(0,r.kt)("h2",{id:"attestermembercount"},"attesterMemberCount"),(0,r.kt)("p",null,"Get the number of members in the attester Semaphore group."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function attesterMemberCount(uint160 attesterId)\n  public\n  view\n  returns (uint256)\n")),(0,r.kt)("h2",{id:"attesterepochroot"},"attesterEpochRoot"),(0,r.kt)("p",null,"Get the epoch tree root for an attester for a certain epoch."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function attesterEpochRoot(uint160 attesterId, uint48 epoch)\n  public\n  view\n  returns (uint256)\n")),(0,r.kt)("h2",{id:"statetreedepth"},"stateTreeDepth"),(0,r.kt)("p",null,"Get the state tree depth for the UniRep contract."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function stateTreeDepth() public view returns (uint8)\n")),(0,r.kt)("h2",{id:"epochtreedepth"},"epochTreeDepth"),(0,r.kt)("p",null,"Get the epoch tree depth for the UniRep contract."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function epochTreeDepth() public view returns (uint8)\n")),(0,r.kt)("h2",{id:"historytreedepth"},"historyTreeDepth"),(0,r.kt)("p",null,"Get the history tree depth for the UniRep contract."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function historyTreeDepth() public view returns (uint8)\n")),(0,r.kt)("h2",{id:"numepochkeynonceperepoch"},"numEpochKeyNoncePerEpoch"),(0,r.kt)("p",null,"Get the maximum nonce value for an epoch key. This determines the number of epoch keys per epoch."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function numEpochKeyNoncePerEpoch() public view returns (uint8)\n")),(0,r.kt)("h2",{id:"fieldcount"},"fieldCount"),(0,r.kt)("p",null,"The number of data fields each user has in this UniRep deployment."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function fieldCount() public view returns (uint8)\n")),(0,r.kt)("h2",{id:"sumfieldcount"},"sumFieldCount"),(0,r.kt)("p",null,"How many of the data fields are combined with addition. The sum fields are the first ",(0,r.kt)("inlineCode",{parentName:"p"},"sumFieldCount")," fields in the user data."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function sumFieldCount() public view returns (uint8)\n")),(0,r.kt)("h2",{id:"replnoncebits"},"replNonceBits"),(0,r.kt)("p",null,"How many nonce bits are in a replacement data field."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function replNonceBits() public view returns (uint8)\n")),(0,r.kt)("h2",{id:"replfieldbits"},"replFieldBits"),(0,r.kt)("p",null,"How many data bits are in a replacement data field."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function replFieldBits() public view returns (uint8)\n")),(0,r.kt)("h2",{id:"chainid"},"chainid"),(0,r.kt)("p",null,"Current chain ID of the UniRep contract."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function chainid() public view returns (uint48)\n")),(0,r.kt)("h2",{id:"defaultdatahash"},"defaultDataHash"),(0,r.kt)("p",null,"The default data hash when a user signs up. It is used to compute a ",(0,r.kt)("a",{parentName:"p",href:"/docs/protocol/trees#state-tree"},"state tree")," leaf"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function defaultDataHash() public view returns (uint256)\n")),(0,r.kt)("h2",{id:"attestationcount"},"attestationCount"),(0,r.kt)("p",null,"The attestation nonce that is used in ",(0,r.kt)("a",{parentName:"p",href:"/docs/protocol/data#replacement-field"},"replacement data field"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},"function attestationCount() public returns (uint48)\n")))}d.isMDXComponent=!0}}]);