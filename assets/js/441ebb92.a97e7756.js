"use strict";(self.webpackChunk_unirep_docs=self.webpackChunk_unirep_docs||[]).push([[4196],{30876:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>m});var r=n(2784);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},s=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,c=e.parentName,s=p(e,["components","mdxType","originalType","parentName"]),u=l(n),h=o,m=u["".concat(c,".").concat(h)]||u[h]||d[h]||i;return n?r.createElement(m,a(a({ref:t},s),{},{components:n})):r.createElement(m,a({ref:t},s))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=h;var p={};for(var c in t)hasOwnProperty.call(t,c)&&(p[c]=t[c]);p.originalType=e,p[u]="string"==typeof e?e:o,a[1]=p;for(var l=2;l<i;l++)a[l]=n[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},99633:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>p,toc:()=>l});var r=n(7896),o=(n(2784),n(30876));const i={title:"Example: UniRep Voting contract"},a=void 0,p={unversionedId:"contracts-api/unirep-voting-sol",id:"contracts-api/unirep-voting-sol",title:"Example: UniRep Voting contract",description:"This is an example contract that utilizes the core UniRep contract and the Voting Prize NFT contract. It can help users anonymously join a hackathon project, anonymously vote, and anonymously claim prize.",source:"@site/docs/contracts-api/unirep-voting-sol.md",sourceDirName:"contracts-api",slug:"/contracts-api/unirep-voting-sol",permalink:"/docs/next/contracts-api/unirep-voting-sol",draft:!1,editUrl:"https://github.com/Unirep/Unirep/tree/main/packages/docs/docs/contracts-api/unirep-voting-sol.md",tags:[],version:"current",frontMatter:{title:"Example: UniRep Voting contract"},sidebar:"apiSidebar",previous:{title:"Unirep.sol",permalink:"/docs/next/contracts-api/unirep-sol"},next:{title:"BaseVerifierHelper.sol",permalink:"/docs/next/contracts-api/verifiers/base-verifier-helper"}},c={},l=[{value:"userSignUp",id:"usersignup",level:2},{value:"joinProject",id:"joinproject",level:2},{value:"vote",id:"vote",level:2},{value:"claimPrize",id:"claimprize",level:2}],s={toc:l},u="wrapper";function d(e){let{components:t,...n}=e;return(0,o.kt)(u,(0,r.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"This is an example contract that utilizes the core UniRep contract and the Voting Prize NFT contract. It can help users anonymously join a hackathon project, anonymously vote, and anonymously claim prize.\n",(0,o.kt)("inlineCode",{parentName:"p"},"UnirepoVoting.sol")," is initialized with the number of projects and ",(0,o.kt)("inlineCode",{parentName:"p"},"VotingPrizeNFT.sol"),". "),(0,o.kt)("p",null,"There are two types of users: hackers and voters. A hacker can join a project of a certain project ID. The voters and hackers can vote for a project ID with one upvote or one downvote. "),(0,o.kt)("p",null,"The project ID has the highest number of vote counts is the winner. All hackers that are part of the project ID can claim an NFT prize.  "),(0,o.kt)("p",null,"To deploy the UnirepVoting contract, we need to first deploy ",(0,o.kt)("inlineCode",{parentName:"p"},"Unirep"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"EpochKeyVerifierHelper"),",  ",(0,o.kt)("inlineCode",{parentName:"p"},"ReputationVerifierHelper"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"VotingPrizeNFT"),". Then initialize the UnirepVoting contract with the deployed addresses and numTeams. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"import {\n    UnirepVoting__factory,\n    VotingPrizeNFT__factory,\n} from '@unirep/contracts/typechain'\n\n  const unirep = await deployUnirep(deployer)\n  const reputationVerifierHelper = await deployVerifierHelper(\n      unirep.address,\n      deployer,\n      Circuit.reputation\n  )\n  const epochKeyVerifierHelper = await deployVerifierHelper(\n      unirep.address,\n      deployer,\n      Circuit.epochKey\n  )\n  const nftF = new VotingPrizeNFT__factory(deployer)\n  const nft = await nftF.deploy(\n      'ipfs://QmNtYnjqeqWbRGC4R7fd9DCXWnQF87ufv7S2zGULtbSpLA'\n  )\n  await nft.deployed()\n\n  const votingF = new UnirepVoting__factory(deployer)\n  const voting = await votingF.deploy(\n      unirep.address,\n      reputationVerifierHelper.address,\n      epochKeyVerifierHelper.address,\n      nft.address,\n      numTeams,\n      epochLength\n  )\n  await nft.setVotingAddress(voting.address).then((t) => t.wait())\n  await voting.deployed()\n")),(0,o.kt)("h2",{id:"usersignup"},"userSignUp"),(0,o.kt)("p",null,"Submit a signup zk proof for a user based on its user state. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sol"},"function userSignUp(\n  uint[] calldata publicSignals,\n  uint[8] calldata proof\n) public\n")),(0,o.kt)("h2",{id:"joinproject"},"joinProject"),(0,o.kt)("p",null,"A hacker can join a project by submitting the project ID, the epoch key proof and public signals. "),(0,o.kt)("p",null,"The projectID must be within the range of numProjects. The public signals must contain ",(0,o.kt)("inlineCode",{parentName:"p"},"revealNonce = true")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"nonce = 0"),". At most 10 hackers can join one project. Epoch key proof must be valid, see ",(0,o.kt)("a",{parentName:"p",href:"/docs/next/contracts-api/verifiers/epoch-key-verifier-helper"},(0,o.kt)("inlineCode",{parentName:"a"},"EpochKeyVerifierHelper")),". To generate the epoch key proof: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"const { publicSignals, proof } = await userState.genEpochKeyProof({\n     nonce: 0,\n     revealNonce: true,\n})\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sol"},"function joinProject(\n    uint256 projectID,\n    uint256[] memory publicSignals,\n    uint256[8] memory proof\n) public\n")),(0,o.kt)("h2",{id:"vote"},"vote"),(0,o.kt)("p",null,"Either a hacker or a voter can vote for a project ID with one of the options (upvote or downvote) along with an epoch key proof and public signals. "),(0,o.kt)("p",null,"The projectID must be within the range of numProjects. The public signal must contain revealNonce = true and nonce = 0. Each hacker or voter can vote at most once. "),(0,o.kt)("p",null,"The epoch key proof must be valid, see ",(0,o.kt)("a",{parentName:"p",href:"/docs/next/contracts-api/verifiers/epoch-key-verifier-helper"},(0,o.kt)("inlineCode",{parentName:"a"},"EpochKeyVerifierHelper")),". "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sol"},"function vote(\n    uint256 projectID,\n    Option option,\n    uint256[] calldata publicSignals,\n    uint256[8] calldata proof\n) public\n")),(0,o.kt)("h2",{id:"claimprize"},"claimPrize"),(0,o.kt)("p",null,"A hacker that belongs to the project ID with the highest score can claim the prize NFT by submitting an address, the reputation proof and its public signals. The minRep in the public signal must be larger or equal than the recorded winner score. A hacker can claim a prize at most once. "),(0,o.kt)("p",null,"The reputation proof must be valid, see ",(0,o.kt)("a",{parentName:"p",href:"/docs/next/contracts-api/verifiers/reputation-verifier-helper"},(0,o.kt)("inlineCode",{parentName:"a"},"ReputationVerifierHelper")),". "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sol"},"function claimPrize(\n    address receiver,\n    uint256[] calldata publicSignals,\n    uint256[8] calldata proof\n) public\n")))}d.isMDXComponent=!0}}]);