"use strict";(self.webpackChunk_unirep_docs=self.webpackChunk_unirep_docs||[]).push([[2366],{30876:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(2784);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),l=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return a.createElement(p.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=l(n),h=r,m=u["".concat(p,".").concat(h)]||u[h]||d[h]||o;return n?a.createElement(m,i(i({ref:t},c),{},{components:n})):a.createElement(m,i({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[u]="string"==typeof e?e:r,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},32065:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=n(7896),r=(n(2784),n(30876));const o={title:"User State"},i=void 0,s={unversionedId:"core-api/user-state",id:"version-2.0.0-beta-4/core-api/user-state",title:"User State",description:"The user state object is used to manage user state for an attester. The state is backed by an anondb instance.",source:"@site/versioned_docs/version-2.0.0-beta-4/core-api/user-state.md",sourceDirName:"core-api",slug:"/core-api/user-state",permalink:"/docs/2.0.0-beta-4/core-api/user-state",draft:!1,editUrl:"https://github.com/Unirep/Unirep/tree/main/packages/docs/versioned_docs/version-2.0.0-beta-4/core-api/user-state.md",tags:[],version:"2.0.0-beta-4",frontMatter:{title:"User State"},sidebar:"apiSidebar",previous:{title:"Subgraph",permalink:"/docs/2.0.0-beta-4/subgraph"},next:{title:"Synchronizer",permalink:"/docs/2.0.0-beta-4/core-api/synchronizer"}},p={},l=[{value:"constructor",id:"constructor",level:2},{value:"commitment",id:"commitment",level:2},{value:"id",id:"id",level:2},{value:"sync",id:"sync",level:2},{value:"prover",id:"prover",level:2},{value:"start",id:"start",level:2},{value:"waitForSync",id:"waitforsync",level:2},{value:"stop",id:"stop",level:2},{value:"hasSignedUp",id:"hassignedup",level:2},{value:"latestTransitionedEpoch",id:"latesttransitionedepoch",level:2},{value:"latestStateTreeLeafIndex",id:"lateststatetreeleafindex",level:2},{value:"getEpochKeys",id:"getepochkeys",level:2},{value:"parseReplData",id:"parserepldata",level:2},{value:"getData",id:"getdata",level:2},{value:"getProvableData",id:"getprovabledata",level:2},{value:"getDataByEpochKey",id:"getdatabyepochkey",level:2},{value:"getEpochKeyIndex",id:"getepochkeyindex",level:2},{value:"genUserStateTransitionProof",id:"genuserstatetransitionproof",level:2},{value:"genProveReputationProof",id:"genprovereputationproof",level:2},{value:"genUserSignUpProof",id:"genusersignupproof",level:2},{value:"genEpochKeyProof",id:"genepochkeyproof",level:2},{value:"genEpochKeyLiteProof",id:"genepochkeyliteproof",level:2}],c={toc:l},u="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The user state object is used to manage user state for an attester. The state is backed by an ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/vimwitch/anondb"},"anondb")," instance."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { UserState } from '@unirep/core'\nimport { defaultProver } from '@unirep/circuits/provers/defaultProver'\nimport { Identity } from '@semaphore-protocol/identity'\n\nconst id = new Identity()\nconst state = new UserState({\n  prover: defaultProver, // a circuit prover\n  unirepAddress: '0xaabbccaabbccaabbccaabbccaabbccaabbccaaaa',\n  provider, // an ethers.js provider\n  id,\n})\n\n// or, initialize with an existing synchronizer object\nconst state = new UserState({\n  synchronizer,\n  id\n})\n\n// start the synchoronizer deamon\nawait state.start()\nawait state.waitForSync()\n\n// stop the synchronizer deamon\nstate.stop()\n")),(0,r.kt)("h2",{id:"constructor"},"constructor"),(0,r.kt)("p",null,"Can be constructed using an existing synchronizer, or by initializing a new synchronizer."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"constructor(\n  config: {\n    synchronizer?: Synchronizer\n    db?: DB\n    attesterId?: bigint | bigint[]\n    unirepAddress?: string\n    provider?: ethers.providers.Provider\n    id: Identity\n    prover: Prover\n  }\n)\n")),(0,r.kt)("h2",{id:"commitment"},"commitment"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://semaphore.appliedzkp.org/"},"Semaphore")," identity commitment of the user."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"state.commitment: bigint\n")),(0,r.kt)("h2",{id:"id"},"id"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://semaphore.appliedzkp.org/"},"Semaphore")," identity of the user."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"state.id: Identity\n")),(0,r.kt)("h2",{id:"sync"},"sync"),(0,r.kt)("p",null,"The underlying synchronizer object."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"state.sync: Synchronizer\n")),(0,r.kt)("h2",{id:"prover"},"prover"),(0,r.kt)("p",null,"The prover object."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"state.prover: Prover\n")),(0,r.kt)("h2",{id:"start"},"start"),(0,r.kt)("p",null,"Convenience accessor for synchronizer ",(0,r.kt)("a",{parentName:"p",href:"/docs/2.0.0-beta-4/core-api/synchronizer#start"},(0,r.kt)("inlineCode",{parentName:"a"},"start")),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"state.start(): Promise<void>\n")),(0,r.kt)("h2",{id:"waitforsync"},"waitForSync"),(0,r.kt)("p",null,"Convenience accessor for synchronizer ",(0,r.kt)("a",{parentName:"p",href:"/docs/2.0.0-beta-4/core-api/synchronizer#waitforsync"},(0,r.kt)("inlineCode",{parentName:"a"},"waitForSync")),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"state.waitForSync(blockNumber?: number): Promise<void>\n")),(0,r.kt)("h2",{id:"stop"},"stop"),(0,r.kt)("p",null,"Convenience accessor for synchronizer ",(0,r.kt)("a",{parentName:"p",href:"/docs/2.0.0-beta-4/core-api/synchronizer#stop"},(0,r.kt)("inlineCode",{parentName:"a"},"stop")),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"state.stop(): void\n")),(0,r.kt)("h2",{id:"hassignedup"},"hasSignedUp"),(0,r.kt)("p",null,"Query the current database if the ",(0,r.kt)("a",{parentName:"p",href:"https://semaphore.appliedzkp.org/"},"Semaphore")," identity commitment is stored."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"state.hasSignedUp(attesterId?: bigint | string): Promise<boolean>\n")),(0,r.kt)("h2",{id:"latesttransitionedepoch"},"latestTransitionedEpoch"),(0,r.kt)("p",null,"Query the current database for a user's signup event or latest user state transition ",(0,r.kt)("a",{parentName:"p",href:"/docs/2.0.0-beta-4/protocol/nullifiers"},"nullifier"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"state.latestTransitionedEpoch(attesterId?: bigint | string): Promise<number>\n")),(0,r.kt)("h2",{id:"lateststatetreeleafindex"},"latestStateTreeLeafIndex"),(0,r.kt)("p",null,"Get the latest state tree leaf index for either the latest transitioned epoch, or the epoch specified."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"state.latestStateTreeLeafIndex(epoch?: number, attesterId?: bigint | string): Promise<number>\n")),(0,r.kt)("h2",{id:"getepochkeys"},"getEpochKeys"),(0,r.kt)("p",null,"Get epoch keys for the current user, for an epoch. If a ",(0,r.kt)("inlineCode",{parentName:"p"},"nonce")," value is supplied the return value will be a single epoch key. Otherwise an array of all epoch keys will be returned."),(0,r.kt)("p",null,"If no ",(0,r.kt)("inlineCode",{parentName:"p"},"epoch")," is supplied the current epoch will be used (as determined by ",(0,r.kt)("a",{parentName:"p",href:"synchronizer#calcCurrentEpoch"},(0,r.kt)("inlineCode",{parentName:"a"},"calcCurrentEpoch")),")."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"state.getEpochKeys(epoch?: number, nonce?: number, attesterId?: bigint | string): bigint | bigint[]\n")),(0,r.kt)("h2",{id:"parserepldata"},"parseReplData"),(0,r.kt)("p",null,"This function is used to parse replacement data field to be ",(0,r.kt)("inlineCode",{parentName:"p"},"index")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"data"),". See ",(0,r.kt)("a",{parentName:"p",href:"/docs/2.0.0-beta-4/protocol/data#replacement-field"},"replacement data field")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"state.parseReplData(replData: bigint): <{data: bigint, nonce: bigint}>\n")),(0,r.kt)("h2",{id:"getdata"},"getData"),(0,r.kt)("p",null,"Get the data for a user up to and including the provided epoch. By default data up to and including the current epoch is returned."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"If you want to make a proof of data make sure to use ",(0,r.kt)("a",{parentName:"p",href:"#getprovabledata"},(0,r.kt)("inlineCode",{parentName:"a"},"getProvableData")),". Data can only be proven once it has been included in a state tree leaf. Learn more about reputation proofs ",(0,r.kt)("a",{parentName:"p",href:"../circuits-api/circuits#prove-reputation-proof"},"here"),".")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"state.getData(toEpoch?: number, attesterId?: bigint | string): Promise<bigint[]>\n")),(0,r.kt)("h2",{id:"getprovabledata"},"getProvableData"),(0,r.kt)("p",null,"Get the data that can be proven by the user using a state tree leaf. This is the data up to, but not including, the epoch the user has transitioned into."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"state.getProvableData(attesterId?: bigint | string): Promise<bigint[]>\n")),(0,r.kt)("h2",{id:"getdatabyepochkey"},"getDataByEpochKey"),(0,r.kt)("p",null,"Get the pending changes to the data owned by an epoch key."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"state.getDataByEpochKey(\n  epochKey: bigint | string, \n  epoch: number, \n  attesterId?: bigint | string\n): Promise<bigint[]>\n")),(0,r.kt)("h2",{id:"getepochkeyindex"},"getEpochKeyIndex"),(0,r.kt)("p",null,"Get the index of epoch key among all attestations."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"state.getEpochKeyIndex(\n  epoch: number, \n  epochKey: bigint | string, \n  attesterId?: bigint | string\n): Promise<number>\n")),(0,r.kt)("h2",{id:"genuserstatetransitionproof"},"genUserStateTransitionProof"),(0,r.kt)("p",null,"Generate a user state transition proof. Returns a ",(0,r.kt)("a",{parentName:"p",href:"../circuits-api/user-state-transition-proof"},(0,r.kt)("inlineCode",{parentName:"a"},"UserStateTransitionProof")),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"state.genUserStateTransitionProof(options?: {\n  toEpoch?: number\n  attesterId?: bigint | string\n}): Promise<UserStateTransitionProof>\n")),(0,r.kt)("h2",{id:"genprovereputationproof"},"genProveReputationProof"),(0,r.kt)("p",null,"Generate a proof of reputation. Returns a ",(0,r.kt)("a",{parentName:"p",href:"../circuits-api/reputation-proof"},(0,r.kt)("inlineCode",{parentName:"a"},"ReputationProof")),"."),(0,r.kt)("admonition",{type:"danger"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"Please avoid assigning the ",(0,r.kt)("inlineCode",{parentName:"strong"},"minRep = data[0] - data[1]")," or ",(0,r.kt)("inlineCode",{parentName:"strong"},"maxRep = data[1] - data[0]"),"."),(0,r.kt)("br",null),"\nThe proof could allow a user to accidentally publish their overall reputation (i.e. ",(0,r.kt)("inlineCode",{parentName:"p"},"data[0]-data[1]"),"). Depending on the circumstances (such as the length of the attestation history) this could reveal a user\u2019s epoch key(s) as well.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"state.genProveReputationProof(options: {\n  epkNonce?: number\n  minRep?: number\n  maxRep?: number\n  graffiti?: bigint | string\n  proveZeroRep?: boolean\n  revealNonce?: boolean\n  data?: bigint | string\n  attesterId?: bigint | string\n}): Promise<ReputationProof>\n")),(0,r.kt)("h2",{id:"genusersignupproof"},"genUserSignUpProof"),(0,r.kt)("p",null,"Generate a proof that can be used to signup. Returns a ",(0,r.kt)("a",{parentName:"p",href:"../circuits-api/signup-proof"},(0,r.kt)("inlineCode",{parentName:"a"},"SignupProof")),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"state.genUserSignUpProof(options: {\n  epoch?: number\n  attesterId?: bigint | string\n}): Promise<SignupProof>\n")),(0,r.kt)("h2",{id:"genepochkeyproof"},"genEpochKeyProof"),(0,r.kt)("p",null,"Generate a proof that a user controls an epoch key in a certain epoch. Optionally provide a data value to sign. Returns an ",(0,r.kt)("a",{parentName:"p",href:"../circuits-api/epoch-key-proof"},(0,r.kt)("inlineCode",{parentName:"a"},"EpochKeyProof")),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"state.genEpochKeyProof(options: {\n  revealNonce?: boolean,\n  nonce?: number,\n  epoch?: number,\n  data?: bigint,\n  attesterId?: bigint | string\n}): Promise<EpochKeyProof>\n")),(0,r.kt)("h2",{id:"genepochkeyliteproof"},"genEpochKeyLiteProof"),(0,r.kt)("p",null,"Generate a proof that a user controls an epoch key in a certain epoch. Optionally provide a data value to sign. Returns an ",(0,r.kt)("a",{parentName:"p",href:"../circuits-api/epoch-key-lite-proof"},(0,r.kt)("inlineCode",{parentName:"a"},"EpochKeyLiteProof")),". This proof ",(0,r.kt)("strong",{parentName:"p"},"will not include a merkle tree proof")," which makes the proof size smaller than an ",(0,r.kt)("a",{parentName:"p",href:"../circuits-api/epoch-key-proof"},(0,r.kt)("inlineCode",{parentName:"a"},"EpochKeyProof")),". It can be used to prove a seen and valid epoch key."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"state.genEpochKeyLiteProof(options: {\n  revealNonce?: boolean,\n  nonce?: number,\n  epoch?: number,\n  data?: bigint,\n  attesterId?: bigint | string\n}): Promise<EpochKeyLiteProof>\n")))}d.isMDXComponent=!0}}]);