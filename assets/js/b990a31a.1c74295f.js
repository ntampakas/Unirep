"use strict";(self.webpackChunk_unirep_docs=self.webpackChunk_unirep_docs||[]).push([[5745],{30876:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>k});var a=n(2784);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),c=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=c(e.components);return a.createElement(p.Provider,{value:t},e.children)},s="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),s=c(n),d=i,k=s["".concat(p,".").concat(d)]||s[d]||u[d]||r;return n?a.createElement(k,l(l({ref:t},m),{},{components:n})):a.createElement(k,l({ref:t},m))}));function k(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=d;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o[s]="string"==typeof e?e:i,l[1]=o;for(var c=2;c<r;c++)l[c]=n[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},81742:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var a=n(7896),i=(n(2784),n(30876));const r={title:"Circom Circuits"},l=void 0,o={unversionedId:"circuits-api/circuits",id:"version-2.1.x/circuits-api/circuits",title:"Circom Circuits",description:"A circuits enum is exported from the package.",source:"@site/versioned_docs/version-2.1.x/circuits-api/circuits.md",sourceDirName:"circuits-api",slug:"/circuits-api/circuits",permalink:"/docs/circuits-api/circuits",draft:!1,editUrl:"https://github.com/Unirep/Unirep/tree/main/packages/docs/versioned_docs/version-2.1.x/circuits-api/circuits.md",tags:[],version:"2.1.x",frontMatter:{title:"Circom Circuits"},sidebar:"apiSidebar",previous:{title:"Prover",permalink:"/docs/circuits-api/interfaces/src.Prover"},next:{title:"Readme",permalink:"/docs/utils-api/"}},p={},c=[{value:"Signup Proof",id:"signup-proof",level:2},{value:"Epoch Key Proof",id:"epoch-key-proof",level:2},{value:"Epoch Key Lite Proof",id:"epoch-key-lite-proof",level:2},{value:"Reputation Proof",id:"reputation-proof",level:2},{value:"User State Transition Proof",id:"user-state-transition-proof",level:2},{value:"Scope Nullifier Proof",id:"scope-nullifier-proof",level:2}],m={toc:c},s="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(s,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A circuits enum is exported from the package."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"enum Circuit {\n  epochKey,\n  reputation,\n  userStateTransition,\n  signup,\n  epochKeyLite,\n  scopeNullifier\n}\n")),(0,i.kt)("p",null,"Use it like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { Circuit } from '@unirep/circuits'\n")),(0,i.kt)("h2",{id:"signup-proof"},"Signup Proof"),(0,i.kt)("p",null,"The signup proof outputs a ",(0,i.kt)("a",{parentName:"p",href:"/docs/protocol/trees#state-tree"},"state tree")," leaf and an ",(0,i.kt)("a",{parentName:"p",href:"https://semaphore.pse.dev/docs/glossary#identity-commitment"},"identity commitment")," for the user. The state tree leaf will have zero values for all data fields."),(0,i.kt)("p",null,"Control field:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"chain id"),(0,i.kt)("th",{parentName:"tr",align:"center"},"epoch"),(0,i.kt)("th",{parentName:"tr",align:"center"},"attester id"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"36 bits"),(0,i.kt)("td",{parentName:"tr",align:"center"},"48 bits"),(0,i.kt)("td",{parentName:"tr",align:"center"},"160 bits")))),(0,i.kt)("p",null,"Inputs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"attester_id")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"epoch")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"identity_secret")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"chain_id"))),(0,i.kt)("p",null,"Outputs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"commitment")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"state_tree_leaf")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"control"))),(0,i.kt)("p",null,"Interface: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'// pragma circom 2.1.0;\n// include "PATH/node_modules/@unirep/circuits/circuits/signup.circom"; \n(commitment, state_tree_leaf, control) <== \n  Signup(FIELD_COUNT)(\n    attester_id, \n    epoch, \n    identity_secret, \n    chain_id\n  );\n')),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Control fields are used to encode many small values into a single field element. This reduces the number of public signals needed to operate a circuit.")),(0,i.kt)("h2",{id:"epoch-key-proof"},"Epoch Key Proof"),(0,i.kt)("p",null,"The epoch key proof allows a user to prove control of an epoch key in a certain epoch. This proof calculates tree things: "),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Merkle inclusion of a state leaf against the current state root"),(0,i.kt)("li",{parentName:"ol"},"An epoch key"),(0,i.kt)("li",{parentName:"ol"},"A data value can be included and endorsed by this proof.")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"nonce")," used to calculate the epoch key may optionally be revealed. This can be used to prevent users from executing an action multiple times using different epoch keys."),(0,i.kt)("p",null,"Control field:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"chain id"),(0,i.kt)("th",{parentName:"tr",align:"center"},"reveal nonce"),(0,i.kt)("th",{parentName:"tr",align:"center"},"attester id"),(0,i.kt)("th",{parentName:"tr",align:"center"},"epoch"),(0,i.kt)("th",{parentName:"tr",align:"center"},"nonce"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"36 bits"),(0,i.kt)("td",{parentName:"tr",align:"center"},"1 bits"),(0,i.kt)("td",{parentName:"tr",align:"center"},"160 bits"),(0,i.kt)("td",{parentName:"tr",align:"center"},"48 bits"),(0,i.kt)("td",{parentName:"tr",align:"center"},"8 bits")))),(0,i.kt)("p",null,"Inputs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"state_tree_indices[STATE_TREE_DEPTH]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"state_tree_elements[STATE_TREE_DEPTH]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"identity_secret")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"reveal_nonce")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"attester_id")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"epoch")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nonce")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"data[FIELD_COUNT]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sig_data")," (public)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"chain_id"))),(0,i.kt)("p",null,"Outputs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"epoch_key")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"state_tree_root")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"control"))),(0,i.kt)("p",null,"Interface: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'// pragma circom 2.1.0;\n// include "PATH/node_modules/@unirep/circuits/circuits/epochKey.circom"; \n(epoch_key, state_tree_root, control) <== EpochKey(STATE_TREE_DEPTH, EPOCH_KEY_NONCE_PER_EPOCH, FIELD_COUNT)(\n  state_tree_indices, \n  state_tree_elements, \n  identity_secret,\n  reveal_nonce,\n  attester_id,\n  epoch,\n  nonce,\n  data,\n  sig_data,\n  chain_id\n);\n')),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Control fields are used to encode many small values into a single field element. This reduces the number of public signals needed to operate a circuit.")),(0,i.kt)("h2",{id:"epoch-key-lite-proof"},"Epoch Key Lite Proof"),(0,i.kt)("p",null,"The epoch key lite proof allows a user to prove control of an epoch key. Unlike the epoch key proof, this proof ",(0,i.kt)("em",{parentName:"p"},"does not perform a state tree inclusion"),". A data value can be included and endorsed by this proof."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"nonce")," used to calculate the epoch key may optionally be revealed. This can be used to prevent users from executing an action multiple times using different epoch keys."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Don't use this proof for keys in the current epoch. If a user has not inserted a leaf into the current state tree they may choose not to accept reputation."),(0,i.kt)("p",{parentName:"admonition"},"Instead this proof is more useful for proving control of keys from past epochs.")),(0,i.kt)("p",null,"Control field:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"chain id"),(0,i.kt)("th",{parentName:"tr",align:"center"},"reveal nonce"),(0,i.kt)("th",{parentName:"tr",align:"center"},"attester id"),(0,i.kt)("th",{parentName:"tr",align:"center"},"epoch"),(0,i.kt)("th",{parentName:"tr",align:"center"},"nonce"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"36 bits"),(0,i.kt)("td",{parentName:"tr",align:"center"},"1 bits"),(0,i.kt)("td",{parentName:"tr",align:"center"},"160 bits"),(0,i.kt)("td",{parentName:"tr",align:"center"},"48 bits"),(0,i.kt)("td",{parentName:"tr",align:"center"},"8 bits")))),(0,i.kt)("p",null,"Inputs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"identity_secret")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"reveal_nonce")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"attester_id")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"epoch")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nonce")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sig_data")," (public)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"chain_id"))),(0,i.kt)("p",null,"Outputs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"control")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"epoch_key"))),(0,i.kt)("p",null,"Interface: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'// pragma circom 2.1.0;\n// include "PATH/node_modules/@unirep/circuits/circuits/epochKeyLite.circom"; \n(control, epoch_key) <== EpochKeyLite(EPOCH_KEY_NONCE_PER_EPOCH)(\n  identity_secret,\n  reveal_nonce,\n  attester_id,\n  epoch,\n  nonce,\n  sig_data,\n  chain_id\n);\n')),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Control fields are used to encode many small values into a single field element. This reduces the number of public signals needed to operate a circuit.")),(0,i.kt)("h2",{id:"reputation-proof"},"Reputation Proof"),(0,i.kt)("p",null,"The prove reputation proof allows a user to prove a reputation balance in the ",(0,i.kt)("a",{parentName:"p",href:"../protocol/trees#state-tree"},"state tree"),". The user is not able to prove reputation received in the current epoch. The user can optionally prove some minimum amount of reputation, maximum amount of reputation, net zero reputation (e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"posRep == negRep"),"), and their graffiti."),(0,i.kt)("p",null,"In this proof, we assign "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"data[0] = posRep")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"data[1] = negRep")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"data[SUM_FIELD_COUNT] = graffiti"),".")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"See ",(0,i.kt)("a",{parentName:"p",href:"/docs/protocol/data"},"data in UniRep protocol")," for more information.")),(0,i.kt)("admonition",{type:"danger"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("strong",{parentName:"p"},"Please avoid assigning the ",(0,i.kt)("inlineCode",{parentName:"strong"},"min_rep = data[0] - data[1]")," or ",(0,i.kt)("inlineCode",{parentName:"strong"},"max_rep = data[1] - data[0]"),"."),(0,i.kt)("br",null),"\nThe proof could allow a user to accidentally publish their overall reputation (i.e. ",(0,i.kt)("inlineCode",{parentName:"p"},"data[0]-data[1]"),"). Depending on the circumstances (such as the length of the attestation history) this could reveal a user\u2019s epoch key(s) as well.")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"nonce")," used to calculate the epoch key may optionally be revealed. This can be used to prevent users from executing an action multiple times using different epoch keys."),(0,i.kt)("p",null,"Control field 0:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"chain id"),(0,i.kt)("th",{parentName:"tr",align:"center"},"reveal nonce"),(0,i.kt)("th",{parentName:"tr",align:"center"},"attester id"),(0,i.kt)("th",{parentName:"tr",align:"center"},"epoch"),(0,i.kt)("th",{parentName:"tr",align:"center"},"nonce"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"36 bits"),(0,i.kt)("td",{parentName:"tr",align:"center"},"1 bits"),(0,i.kt)("td",{parentName:"tr",align:"center"},"160 bits"),(0,i.kt)("td",{parentName:"tr",align:"center"},"48 bits"),(0,i.kt)("td",{parentName:"tr",align:"center"},"8 bits")))),(0,i.kt)("p",null,"Control field 1:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"prove graffiti"),(0,i.kt)("th",{parentName:"tr",align:"center"},"prove zero rep"),(0,i.kt)("th",{parentName:"tr",align:"center"},"prove max rep"),(0,i.kt)("th",{parentName:"tr",align:"center"},"prove min rep"),(0,i.kt)("th",{parentName:"tr",align:"center"},"max rep"),(0,i.kt)("th",{parentName:"tr",align:"center"},"min rep"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"1 bit"),(0,i.kt)("td",{parentName:"tr",align:"center"},"1 bit"),(0,i.kt)("td",{parentName:"tr",align:"center"},"1 bit"),(0,i.kt)("td",{parentName:"tr",align:"center"},"1 bit"),(0,i.kt)("td",{parentName:"tr",align:"center"},"64 bits"),(0,i.kt)("td",{parentName:"tr",align:"center"},"64 bits")))),(0,i.kt)("p",null,"Inputs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"identity_secret")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"state_tree_indices[STATE_TREE_DEPTH]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"state_tree_elements[STATE_TREE_DEPTH]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"data[FIELD_COUNT]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"prove_graffiti")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"graffiti")," (public)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"reveal_nonce")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"attester_id")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"epoch")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nonce")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"chain_id")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"min_rep")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"max_rep")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"prove_min_rep")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"prove_max_rep")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"prove_zero_rep")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sig_data")," (public)")),(0,i.kt)("p",null,"Outputs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"epoch_key")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"state_tree_root")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"control[2]"))),(0,i.kt)("p",null,"Interface: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'// pragma circom 2.1.0;\n// include "PATH/node_modules/@unirep/circuits/circuits/reputation.circom"; \n(epoch_key, state_tree_root, control) <== Reputation(STATE_TREE_DEPTH, EPOCH_KEY_NONCE_PER_EPOCH, SUM_FIELD_COUNT, FIELD_COUNT, REPL_NONCE_BITS)(\n  identity_secret,\n  state_tree_indices,\n  state_tree_elements,\n  data,\n  prove_graffiti,\n  graffiti,\n  reveal_nonce,\n  attester_id,\n  epoch,\n  nonce,\n  chain_id,\n  min_rep,\n  max_rep,\n  prove_min_rep,\n  prove_max_rep,\n  prove_zero_rep,\n  sig_data\n);\n')),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Control fields are used to encode many small values into a single field element. This reduces the number of public signals needed to operate a circuit.")),(0,i.kt)("h2",{id:"user-state-transition-proof"},"User State Transition Proof"),(0,i.kt)("p",null,"The user state transition proof allows a user to prove how much reputation they have at the end of an epoch and output a new state tree leaf. The proof calculates an inclusion proof for the state tree, and for each epoch key nonce an inclusion proof for the epoch tree. If the epoch key does not exist in the epoch tree it is instead output as a public signal. If the epoch key does exist in the tree a random value will be output instead. The verifier ",(0,i.kt)("em",{parentName:"p"},"must")," check that the output epoch keys are not included in the epoch tree."),(0,i.kt)("p",null,"Once it has proved inclusion it sums the reputation values stored in the leaves. Then it takes the replacement values with the highest timestamps and outputs a new state tree leaf for the next epoch."),(0,i.kt)("p",null,"Control field:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"to epoch"),(0,i.kt)("th",{parentName:"tr",align:"center"},"attester id"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"48 bits"),(0,i.kt)("td",{parentName:"tr",align:"center"},"160 bits")))),(0,i.kt)("p",null,"Inputs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"from_epoch")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"to_epoch")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"identity_secret")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"state_tree_indices[STATE_TREE_DEPTH]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"state_tree_elements[STATE_TREE_DEPTH]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"history_tree_indices[HISTORY_TREE_DEPTH]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"history_tree_elements[HISTORY_TREE_DEPTH]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"attester_id")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"data[FIELD_COUNT]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"new_data[EPOCH_KEY_NONCE_PER_EPOCH][FIELD_COUNT]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"epoch_tree_root")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"epoch_tree_elements[EPOCH_KEY_NONCE_PER_EPOCH][EPOCH_TREE_DEPTH]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"epoch_tree_indices[EPOCH_KEY_NONCE_PER_EPOCH][EPOCH_TREE_DEPTH]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"chain_id"))),(0,i.kt)("p",null,"Outputs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"history_tree_root")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"state_tree_leaf")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"epks[EPOCH_KEY_NONCE_PER_EPOCH]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"control"))),(0,i.kt)("p",null,"Interface: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'// pragma circom 2.1.0;\n// include "PATH/node_modules/@unirep/circuits/circuits/userStateTransition.circom"; \n(history_tree_root, state_tree_leaf, epks, control) <== UserStateTransition(\n  STATE_TREE_DEPTH,\n  EPOCH_TREE_DEPTH,\n  HISTORY_TREE_DEPTH,\n  EPOCH_KEY_NONCE_PER_EPOCH,\n  FIELD_COUNT,\n  SUM_FIELD_COUNT,\n  REPL_NONCE_BITS\n)(\n  from_epoch,\n  to_epoch,\n  identity_secret,\n  state_tree_indices,\n  state_tree_elements,\n  history_tree_indices,\n  history_tree_elements,\n  attester_id,\n  data,\n  new_data,\n  epoch_tree_root,\n  epoch_tree_elements,\n  epoch_tree_indices,\n  chain_id\n);\n')),(0,i.kt)("h2",{id:"scope-nullifier-proof"},"Scope Nullifier Proof"),(0,i.kt)("p",null,"The scope nullifier proof will prevents users from doing the same action within a scope again. It checks if the user has already signed up in a UniRep attester and outputs a scope nullifier.\nThe nullifier will be computed by ",(0,i.kt)("inlineCode",{parentName:"p"},"hash(scope, secret)")),(0,i.kt)("p",null,"Control field:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"chain id"),(0,i.kt)("th",{parentName:"tr",align:"center"},"reveal nonce"),(0,i.kt)("th",{parentName:"tr",align:"center"},"attester id"),(0,i.kt)("th",{parentName:"tr",align:"center"},"epoch"),(0,i.kt)("th",{parentName:"tr",align:"center"},"nonce"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"36 bits"),(0,i.kt)("td",{parentName:"tr",align:"center"},"1 bits"),(0,i.kt)("td",{parentName:"tr",align:"center"},"160 bits"),(0,i.kt)("td",{parentName:"tr",align:"center"},"48 bits"),(0,i.kt)("td",{parentName:"tr",align:"center"},"8 bits")))),(0,i.kt)("p",null,"Inputs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"state_tree_indices[STATE_TREE_DEPTH]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"state_tree_elements[STATE_TREE_DEPTH]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"reveal_nonce")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"attester_id")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"epoch")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nonce")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sig_data")," (public)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"identity_secret")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"scope")," (public)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"data[FIELD_COUNT]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"chain_id"))),(0,i.kt)("p",null,"Outputs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"epoch_key")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"state_tree_root")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"control")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nullifier"))),(0,i.kt)("p",null,"Interface: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'// pragma circom 2.1.0;\n// include "PATH/node_modules/@unirep/circuits/circuits/scopeNullifier.circom"; \n(epoch_key, state_tree_root, control, nullifier) <== ScopeNullifier(STATE_TREE_DEPTH, EPOCH_KEY_NONCE_PER_EPOCH, FIELD_COUNT)(\n  state_tree_indices, \n  state_tree_elements,\n  reveal_nonce, \n  attester_id,\n  epoch,\n  nonce,\n  sig_data,\n  identity_secret,\n  scope,\n  data,\n  chain_id\n);\n')),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Control fields are used to encode many small values into a single field element. This reduces the number of public signals needed to operate a circuit.")))}u.isMDXComponent=!0}}]);