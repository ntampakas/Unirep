"use strict";(self.webpackChunk_unirep_docs=self.webpackChunk_unirep_docs||[]).push([[3425],{30876:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var r=n(2784);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),h=a,m=u["".concat(s,".").concat(h)]||u[h]||d[h]||o;return n?r.createElement(m,i(i({ref:t},p),{},{components:n})):r.createElement(m,i({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},91908:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var r=n(7896),a=(n(2784),n(30876));const o={title:"Synchronizer"},i=void 0,l={unversionedId:"core-api/synchronizer",id:"version-2.0.0-beta-4/core-api/synchronizer",title:"Synchronizer",description:"Used to retrieve and manage state information for a UniRep attester. Each instance is backed by an anondb instance.",source:"@site/versioned_docs/version-2.0.0-beta-4/core-api/synchronizer.md",sourceDirName:"core-api",slug:"/core-api/synchronizer",permalink:"/docs/2.0.0-beta-4/core-api/synchronizer",draft:!1,editUrl:"https://github.com/Unirep/Unirep/tree/main/packages/docs/versioned_docs/version-2.0.0-beta-4/core-api/synchronizer.md",tags:[],version:"2.0.0-beta-4",frontMatter:{title:"Synchronizer"},sidebar:"apiSidebar",previous:{title:"User State",permalink:"/docs/2.0.0-beta-4/core-api/user-state"},next:{title:"schema",permalink:"/docs/2.0.0-beta-4/core-api/schema"}},s={},c=[{value:"constructor",id:"constructor",level:2},{value:"db",id:"db",level:2},{value:"provider",id:"provider",level:2},{value:"unirepContract",id:"unirepcontract",level:2},{value:"settings",id:"settings",level:2},{value:"attesterId",id:"attesterid",level:2},{value:"setAttesterId",id:"setattesterid",level:2},{value:"start",id:"start",level:2},{value:"stop",id:"stop",level:2},{value:"poll",id:"poll",level:2},{value:"pollRate",id:"pollrate",level:2},{value:"blockRate",id:"blockrate",level:2},{value:"waitForSync",id:"waitforsync",level:2},{value:"calcCurrentEpoch",id:"calccurrentepoch",level:2},{value:"calcEpochRemainingTime",id:"calcepochremainingtime",level:2},{value:"readCurrentEpoch",id:"readcurrentepoch",level:2},{value:"loadCurrentEpoch",id:"loadcurrentepoch",level:2},{value:"epochTreeRoot",id:"epochtreeroot",level:2},{value:"epochTreeProof",id:"epochtreeproof",level:2},{value:"nullifierExist",id:"nullifierexist",level:2},{value:"genStateTree",id:"genstatetree",level:2},{value:"genEpochTree",id:"genepochtree",level:2},{value:"genHistoryTree",id:"genhistorytree",level:2},{value:"stateTreeRootExists",id:"statetreerootexists",level:2},{value:"epochTreeRootExists",id:"epochtreerootexists",level:2},{value:"numStateTreeLeaves",id:"numstatetreeleaves",level:2}],p={toc:c},u="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Used to retrieve and manage state information for a UniRep attester. Each instance is backed by an ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/vimwitch/anondb"},"anondb")," instance."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { Synchronizer } from '@unirep/core'\n\nconst state = new Synchronizer({\n  unirepAddress: '0xaabbccaabbccaabbccaabbccaabbccaabbccaaaa',\n  provider, // an ethers.js provider\n})\n\n// start the synchronizer deamon\nawait state.start()\nawait state.waitForSync()\n\n// stop the synchronizer deamon\nstate.stop()\n")),(0,a.kt)("h2",{id:"constructor"},"constructor"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"constructor(config: {\n    db?: DB\n    attesterId?: bigint | bigint[]\n    provider: ethers.providers.Provider\n    unirepAddress: string\n})\n")),(0,a.kt)("h2",{id:"db"},"db"),(0,a.kt)("p",null,"The database object."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"synchronizer.db: DB\n")),(0,a.kt)("h2",{id:"provider"},"provider"),(0,a.kt)("p",null,"The provider which is connected in the synchronizer."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"synchronizer.provider: ethers.providers.Provider\n")),(0,a.kt)("h2",{id:"unirepcontract"},"unirepContract"),(0,a.kt)("p",null,"The UniRep smart contract object which is connected in the synchronizer."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"synchronizer.unirepContract: ethers.Contract\n")),(0,a.kt)("h2",{id:"settings"},"settings"),(0,a.kt)("p",null,"The settings of the UniRep smart contract."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"synchronizer.settings: any\n")),(0,a.kt)("h2",{id:"attesterid"},"attesterId"),(0,a.kt)("p",null,"The default attester ID that is set when construction.\nIf there is a list of attester IDs, then the first one will be the default attester ID.\nIf no attester ID is given during construction, all attesters will be synchronized. And the default ",(0,a.kt)("inlineCode",{parentName:"p"},"attesterId")," would be ",(0,a.kt)("inlineCode",{parentName:"p"},"BigInt(0)"),"."),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"Should check which default attester Id is carefully while synchronizing more than one attester. The default attester ID could be changed through ",(0,a.kt)("a",{parentName:"p",href:"#setattesterid"},"setAttesterId"),".")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"synchronizer.attesterId: bigint\n")),(0,a.kt)("h2",{id:"setattesterid"},"setAttesterId"),(0,a.kt)("p",null,"Change default ",(0,a.kt)("a",{parentName:"p",href:"#attesterid"},"attesterId")," to another attester ID. It will fail if an ",(0,a.kt)("inlineCode",{parentName:"p"},"attesterId")," is not synchronized when construction."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"synchronizer.setAttesterId(attesterId: string | bigint): void\n")),(0,a.kt)("h2",{id:"start"},"start"),(0,a.kt)("p",null,"Start the synchronizer daemon."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"synchronizer.start(): Promise<void>\n")),(0,a.kt)("h2",{id:"stop"},"stop"),(0,a.kt)("p",null,"Stop the synchronizer daemon."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"synchronizer.stop(): void\n")),(0,a.kt)("h2",{id:"poll"},"poll"),(0,a.kt)("p",null,"Manually poll for new events. Returns a boolean indicating whether the synchronizer has synced to the head of the blockchain."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"synchronizer.poll(): Promise<{ complete: boolean }>\n")),(0,a.kt)("h2",{id:"pollrate"},"pollRate"),(0,a.kt)("p",null,"How frequently the synchronizer will poll the blockchain for new events (specified in milliseconds). Default: ",(0,a.kt)("inlineCode",{parentName:"p"},"5000")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"synchronizer.pollRate\n")),(0,a.kt)("h2",{id:"blockrate"},"blockRate"),(0,a.kt)("p",null,"How many blocks the synchronizer will query on each poll. Default: ",(0,a.kt)("inlineCode",{parentName:"p"},"100000")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"synchronizer.blockRate\n")),(0,a.kt)("h2",{id:"waitforsync"},"waitForSync"),(0,a.kt)("p",null,"Wait for the synchronizer to sync up to a certain block. By default this will wait until the current latest known block (according to the provider)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"synchronizer.waitForSync(blockNumber?: number): Promise<void>\n")),(0,a.kt)("h2",{id:"calccurrentepoch"},"calcCurrentEpoch"),(0,a.kt)("p",null,"Calculate the current epoch determining the amount of time since the attester registration timestamp. This operation is ",(0,a.kt)("strong",{parentName:"p"},"synchronous")," and does not involve any database operations."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"synchronizer.calcCurrentEpoch(attesterId?: bigint | string): number\n")),(0,a.kt)("h2",{id:"calcepochremainingtime"},"calcEpochRemainingTime"),(0,a.kt)("p",null,"Calculate the amount of time remaining in the current epoch. This operation is ",(0,a.kt)("strong",{parentName:"p"},"synchronous")," and does not involve any database operations."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"synchronizer.calcEpochRemainingTime(attesterId?: bigint | string): number\n")),(0,a.kt)("h2",{id:"readcurrentepoch"},"readCurrentEpoch"),(0,a.kt)("p",null,"Get the latest processed epoch from the database."),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"This value may mismatch the onchain value depending on synchronization status.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"synchronizer.readCurrentEpoch(attesterId?: bigint | string): Promise<{\n  number: number,\n  sealed: boolean\n}>\n")),(0,a.kt)("h2",{id:"loadcurrentepoch"},"loadCurrentEpoch"),(0,a.kt)("p",null,"Load the current epoch number from the blockchain."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Use this function in test environments where the blockchain timestamp may not match the real timestamp (e.g. due to snapshot/revert patterns).")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"synchronizer.loadCurrentEpoch(attesterId?: bigint | string): Promise<number>\n")),(0,a.kt)("h2",{id:"epochtreeroot"},"epochTreeRoot"),(0,a.kt)("p",null,"Get the epoch tree root for a certain epoch."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"synchronizer.epochTreeRoot(\n  epoch: number, \n  attesterId?: bigint | string\n): Promise<bigint>\n")),(0,a.kt)("h2",{id:"epochtreeproof"},"epochTreeProof"),(0,a.kt)("p",null,"Build a merkle inclusion proof for the tree from a certain epoch."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"synchronizer.epochTreeProof(\n  epoch: number, \n  leafIndex: bigint, \n  attesterId?: bigint | string\n): Promise<bigint[]>\n")),(0,a.kt)("h2",{id:"nullifierexist"},"nullifierExist"),(0,a.kt)("p",null,"Determine if a ",(0,a.kt)("a",{parentName:"p",href:"/docs/2.0.0-beta-4/protocol/nullifiers"},"nullifier")," exists. All nullifiers are stored in a single mapping and expected to be globally unique."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"synchronizer.nullifierExist(nullifier: any): Promise<boolean>\n")),(0,a.kt)("h2",{id:"genstatetree"},"genStateTree"),(0,a.kt)("p",null,"Build the latest state tree for a certain epoch."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"synchronizer.genStateTree(\n  epoch: number | bigint, \n  attesterId?: bigint | string\n): Promise<IncrementalMerkleTree>\n")),(0,a.kt)("h2",{id:"genepochtree"},"genEpochTree"),(0,a.kt)("p",null,"Build the latest epoch tree for a certain epoch."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"synchronizer.genEpochTree(\n  epoch: number | bigint, \n  attesterId?: bigint | string\n): Promise<IncrementalMerkleTree>\n")),(0,a.kt)("h2",{id:"genhistorytree"},"genHistoryTree"),(0,a.kt)("p",null,"Build the latest history tree for the current attester."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"synchronizer.genHistoryTree(): Promise<IncrementalMerkleTree>\n")),(0,a.kt)("h2",{id:"statetreerootexists"},"stateTreeRootExists"),(0,a.kt)("p",null,"Determine if a state root exists in a certain epoch."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"synchronizer.stateTreeRootExists(\n  root: bigint | string, \n  epoch: number, \n  attesterId?: bigint | string\n): Promise<boolean>\n")),(0,a.kt)("h2",{id:"epochtreerootexists"},"epochTreeRootExists"),(0,a.kt)("p",null,"Determine if an epoch tree root exists for a certain epoch."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"synchronizer.epochTreeRootExists(\n  root: bigint | string, \n  epoch: number\n): Promise<boolean>\n")),(0,a.kt)("h2",{id:"numstatetreeleaves"},"numStateTreeLeaves"),(0,a.kt)("p",null,"Get the number of state tree leaves in a certain epoch."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"synchronizer.numStateTreeLeaves(\n  epoch: number, \n  attesterId?: bigint | string\n): Promise<number>\n")))}d.isMDXComponent=!0}}]);