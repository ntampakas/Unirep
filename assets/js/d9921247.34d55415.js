"use strict";(self.webpackChunk_unirep_docs=self.webpackChunk_unirep_docs||[]).push([[3253],{30876:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var i=n(2784);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),p=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return i.createElement(l.Provider,{value:t},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(n),d=a,m=c["".concat(l,".").concat(d)]||c[d]||h[d]||r;return n?i.createElement(m,o(o({ref:t},u),{},{components:n})):i.createElement(m,o({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:a,o[1]=s;for(var p=2;p<r;p++)o[p]=n[p];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4667:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var i=n(7896),a=(n(2784),n(30876));const r={description:"The zero-knowledge circuit of user state transition proof in UniRep"},o="User State Transition Proof",s={unversionedId:"protocol/circuits/user-state-transition-proof",id:"version-1.0.1/protocol/circuits/user-state-transition-proof",title:"User State Transition Proof",description:"The zero-knowledge circuit of user state transition proof in UniRep",source:"@site/versioned_docs/version-1.0.1/protocol/circuits/user-state-transition-proof.md",sourceDirName:"protocol/circuits",slug:"/protocol/circuits/user-state-transition-proof",permalink:"/docs/1.0.1/protocol/circuits/user-state-transition-proof",draft:!1,editUrl:"https://github.com/Unirep/Unirep/tree/main/packages/docs/versioned_docs/version-1.0.1/protocol/circuits/user-state-transition-proof.md",tags:[],version:"1.0.1",frontMatter:{description:"The zero-knowledge circuit of user state transition proof in UniRep"},sidebar:"apiSidebar",previous:{title:"User Sign Up Proof",permalink:"/docs/1.0.1/protocol/circuits/user-sign-up-proof"},next:{title:"Attestations",permalink:"/docs/1.0.1/protocol/contract/attestations"}},l={},p=[{value:"1. Start Transition proof",id:"1-start-transition-proof",level:2},{value:"Public outputs",id:"public-outputs",level:3},{value:"Private inputs",id:"private-inputs",level:3},{value:"Contraints",id:"contraints",level:3},{value:"1. Check if user exists in the Global State Tree",id:"1-check-if-user-exists-in-the-global-state-tree",level:4},{value:"2. Compute blinded public output",id:"2-compute-blinded-public-output",level:4},{value:"2. Process attestations proof",id:"2-process-attestations-proof",level:2},{value:"Public inputs",id:"public-inputs",level:3},{value:"Public outputs",id:"public-outputs-1",level:3},{value:"Private inputs",id:"private-inputs-1",level:3},{value:"Contraints",id:"contraints-1",level:3},{value:"1. Verify blinded input user state",id:"1-verify-blinded-input-user-state",level:4},{value:"2. Verify attestation hash chain",id:"2-verify-attestation-hash-chain",level:4},{value:"3. Process attestations and update user state tree",id:"3-process-attestations-and-update-user-state-tree",level:4},{value:"4. Compute blinded public output",id:"4-compute-blinded-public-output",level:4},{value:"3. User State Transition proof",id:"3-user-state-transition-proof",level:2},{value:"Public inputs",id:"public-inputs-1",level:3},{value:"Public outputs",id:"public-outputs-2",level:3},{value:"Private inputs",id:"private-inputs-2",level:3},{value:"Contraints",id:"contraints-2",level:3},{value:"1. Check if user exists in the Global State Tree",id:"1-check-if-user-exists-in-the-global-state-tree-1",level:4},{value:"2. Process the hashchain of the epoch key specified by nonce <code>n</code>",id:"2-process-the-hashchain-of-the-epoch-key-specified-by-nonce-n",level:4},{value:"3. Check if blinded user state matches",id:"3-check-if-blinded-user-state-matches",level:4},{value:"4. Compute and output nullifiers and new GST leaf",id:"4-compute-and-output-nullifiers-and-new-gst-leaf",level:4}],u={toc:p},c="wrapper";function h(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"user-state-transition-proof"},"User State Transition Proof"),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"/docs/1.0.1/protocol/glossary/user-state-transition"},"user state transition")," proof is used to process attestations from the latest epoch the user transitioned and then compute the latest ",(0,a.kt)("a",{parentName:"p",href:"/docs/1.0.1/protocol/glossary/trees#global-state-tree"},"global state tree")," leaf."),(0,a.kt)("p",null,"The user state transition circuit checks that"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"The user has ",(0,a.kt)("a",{parentName:"p",href:"../glossary/users-and-attesters#user"},"registered")," and performed ",(0,a.kt)("a",{parentName:"p",href:"/docs/1.0.1/protocol/glossary/user-state-transition"},"user state transition")," in the previous epoch.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"The ",(0,a.kt)("a",{parentName:"p",href:"/docs/1.0.1/protocol/glossary/trees#user-state-tree"},"user state tree")," is updated correctly by the attestations, and the same attestations are chained by hash functions."),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"For example, the original user state tree root is ",(0,a.kt)("inlineCode",{parentName:"li"},"r_1"),", and the original user state tree leaf has 5 positive reputation")),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"user_state_tree_leaf = hash(5, 0, 0, 0, 0)\n")),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"An incoming attestation has",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"attester_id = 1")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"pos_rep = 3")))),(0,a.kt)("li",{parentName:"ul"},"compute the hash of ",(0,a.kt)("a",{parentName:"li",href:"/docs/1.0.1/protocol/glossary/reputation#reputation"},"reputation"))),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"hash_reputation = hash(5 + 3, 0, 0, 0, 0)\n")),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"compute the updated user state tree root ",(0,a.kt)("inlineCode",{parentName:"li"},"r_2")," with user state tree leaf ",(0,a.kt)("inlineCode",{parentName:"li"},"hash(8, 0, 0, 0, 0)")," in the leaf index ",(0,a.kt)("inlineCode",{parentName:"li"},"1")),(0,a.kt)("li",{parentName:"ul"},"compute the hash of ",(0,a.kt)("a",{parentName:"li",href:"/docs/1.0.1/protocol/glossary/reputation#attestation"},"attestation"))),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"hash_attestation = hash(1, 3, 0, 0, 0)\n")),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"compute the hash chain")),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"hash_chain = hash(hash_attestation, hash_chain)\n"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"After all attestations of all epoch keys are processed, the circuit seals all hash chains and computes the ",(0,a.kt)("a",{parentName:"p",href:"/docs/1.0.1/protocol/glossary/trees#epoch-tree"},"epoch tree"),". (If the output epoch tree root mismatches others' epoch tree roots, then the user state transition proof is invalid because the user process attestations in a wrong way.)")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Compute the updated global state tree leaf by"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"hash(identity_commitment, updated_user_state_root)\n")),(0,a.kt)("p",null,"Ideally, the user state transition proof should be in ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/appliedzkp/UniRep/blob/5701dd3c060c332e8e83895c49e3a90b3fca3c49/circuits/userStateTransition.circom"},"one circuit"),". But the circuit size is too big to generate a proof in a browser, we separate the proof into three different parts: ",(0,a.kt)("strong",{parentName:"p"},"start transition proof"),", ",(0,a.kt)("strong",{parentName:"p"},"process attestations proof"),", and ",(0,a.kt)("strong",{parentName:"p"},"user state transition proof"),"."),(0,a.kt)("p",null,"The idea of chaining these three proofs but without revealing user's sensitive information is to use ",(0,a.kt)("inlineCode",{parentName:"p"},"blinded_user_state")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"blinded_hash_chain")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const blinded_user_state = hash(\n    identity_nullifier, \n    user_tree_root, \n    epoch, \n    from_epoch_key_nonce\n)\nconst blinded_hash_chain = hash(\n    identity_nullifier, \n    current_hash_chain, \n    epoch, \n    from_epoch_key_nonce\n)\n")),(0,a.kt)("p",null,"In the ",(0,a.kt)("strong",{parentName:"p"},"start transition proof"),", the circuit will compute the initial ",(0,a.kt)("inlineCode",{parentName:"p"},"blinded_user_state")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"blinded_hash_chain"),", the ",(0,a.kt)("inlineCode",{parentName:"p"},"user_tree_root")," is the latest transitioned user state tree and the ",(0,a.kt)("inlineCode",{parentName:"p"},"hash(identity_commitment, updated_user_state_root)")," should be in a global state tree. The ",(0,a.kt)("inlineCode",{parentName:"p"},"current_hash_chain")," is start with ",(0,a.kt)("inlineCode",{parentName:"p"},"0")," as the definition of hash chain."),(0,a.kt)("img",{src:"/img/v1/blind.png",alt:"How blinded user states and blinded hash chains are computed."}),(0,a.kt)("p",null,"After ",(0,a.kt)("inlineCode",{parentName:"p"},"blinded_user_state")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"blinded_hash_chain")," are submitted, the user can take them as public inputs and start to ",(0,a.kt)("strong",{parentName:"p"},"process attestations")," according to the ",(0,a.kt)("inlineCode",{parentName:"p"},"user_tree_root")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"current_hash_chain"),". When the attestations limit reaches (e.g. a ",(0,a.kt)("inlineCode",{parentName:"p"},"processAttestations")," circuit can process only 10 attestations per proof) or all attestations to the epoch key are processed, the circuit will output another ",(0,a.kt)("inlineCode",{parentName:"p"},"blinded_user_state")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"blinded_hash_chain")," to continue processing attestations."),(0,a.kt)("img",{src:"/img/v1/process-attestations.png",alt:"How hash chain is processed in process attestations proofs."}),(0,a.kt)("img",{src:"/img/v1/update-trees.png",alt:"How user state tree is processed in process attestation proofs."}),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"epoch_key_nonce")," is used in the blinded user state and blinded hash chain to indicate the attestations of which epoch key is processed. In the final ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"userStateTransition"))," proof, it checks all epoch key with different ",(0,a.kt)("inlineCode",{parentName:"p"},"epoch_key_nonce")," are processed and the hash chain result matches the ",(0,a.kt)("a",{parentName:"p",href:"/docs/1.0.1/protocol/glossary/trees#epoch-tree"},"epoch tree"),"."),(0,a.kt)("p",null,"There are only one user state tree result after all attestations are processed, so in the final proof it only takes the initial ",(0,a.kt)("inlineCode",{parentName:"p"},"blinded_user_state")," and the final one and computes the new global state tree leaf. On the other hand, there are ",(0,a.kt)("inlineCode",{parentName:"p"},"numEpochKeyNoncePerEpoch")," hash chains after processing attestations, so the final circuit will take ",(0,a.kt)("inlineCode",{parentName:"p"},"numEpochKeyNoncePerEpoch")," ",(0,a.kt)("inlineCode",{parentName:"p"},"blinded_hash_chain")," to check the epoch tree root."),(0,a.kt)("img",{src:"/img/v1/check-epoch-tree-root.png",alt:"How the final user state transition proof verifies hash chains and user states."}),(0,a.kt)("p",null,"The user state tree root is continuously updated: the output should be the input of another proof, so the ",(0,a.kt)("inlineCode",{parentName:"p"},"processAttestation")," proof takes ",(0,a.kt)("inlineCode",{parentName:"p"},"blinded_user_state")," as public input and output another ",(0,a.kt)("inlineCode",{parentName:"p"},"blinded_user_state"),". The hash chain results might not be continuously. When all attestations of one epoch key is processed, the hash chain of the next epoch key should be ",(0,a.kt)("inlineCode",{parentName:"p"},"0")," but not the previous hash chain. Therefore, ",(0,a.kt)("inlineCode",{parentName:"p"},"processAttestation")," proof does not take ",(0,a.kt)("inlineCode",{parentName:"p"},"blinded_hash_chain")," as input."),(0,a.kt)("p",null,"While verifying all of the proofs, there are the following things to check to make sure it follows the rules:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"startTransitionProof")," takes a valid global state tree root as a public input."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"processAttestationsProof")," takes ",(0,a.kt)("inlineCode",{parentName:"li"},"blinded_user_state")," as public input and ",(0,a.kt)("inlineCode",{parentName:"li"},"blinded_hash_chain")," as private input from either ",(0,a.kt)("inlineCode",{parentName:"li"},"startTransitionProof")," or another ",(0,a.kt)("inlineCode",{parentName:"li"},"processAttestationsProof"),"."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"userStateTransitionProof")," takes two ",(0,a.kt)("inlineCode",{parentName:"li"},"blinded_user_state"),", one is from ",(0,a.kt)("inlineCode",{parentName:"li"},"startTransitionProof")," and the other is from the latest ",(0,a.kt)("inlineCode",{parentName:"li"},"processAttestationsProof"),"."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"userStateTransitionProof")," takes ",(0,a.kt)("inlineCode",{parentName:"li"},"numEpochKeyNoncePerEpoch")," ",(0,a.kt)("inlineCode",{parentName:"li"},"blinded_hash_chain")," from ",(0,a.kt)("inlineCode",{parentName:"li"},"processAttestationsProof"),".")),(0,a.kt)("h2",{id:"1-start-transition-proof"},"1. Start Transition proof"),(0,a.kt)("h3",{id:"public-outputs"},"Public outputs"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"GST_root")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"blinded_user_state")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"blinded_hash_chain_result"))),(0,a.kt)("h3",{id:"private-inputs"},"Private inputs"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"epoch")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"epoch_key_nonce")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"user_tree_root")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_nullifier")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_trapdoor")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"GST_path_elements")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"GST_path_index"))),(0,a.kt)("h3",{id:"contraints"},"Contraints"),(0,a.kt)("h4",{id:"1-check-if-user-exists-in-the-global-state-tree"},"1. Check if user exists in the Global State Tree"),(0,a.kt)("p",null,"Check if ",(0,a.kt)("inlineCode",{parentName:"p"},"hash(identity_commitment, UST_root)")," is one of the leaves in the global state tree of root ",(0,a.kt)("inlineCode",{parentName:"p"},"GST_root"),"."),(0,a.kt)("h4",{id:"2-compute-blinded-public-output"},"2. Compute blinded public output"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const blinded_user_state = hash(\n    identity_nullifier, \n    user_tree_root, \n    epoch, \n    from_epoch_key_nonce\n)\nconst blinded_hash_chain = hash(\n    identity_nullifier, \n    current_hash_chain, \n    epoch, \n    from_epoch_key_nonce\n)\n")),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"See the whole circuit in ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/Unirep/Unirep/blob/v1.0.1/packages/circuits/circuits/startTransition.circom"},"circuits/startTransition.circom"))),(0,a.kt)("h2",{id:"2-process-attestations-proof"},"2. Process attestations proof"),(0,a.kt)("h3",{id:"public-inputs"},"Public inputs"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"input_blinded_user_state"))),(0,a.kt)("h3",{id:"public-outputs-1"},"Public outputs"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"blinded_user_state")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"blinded_hash_chain_result"))),(0,a.kt)("h3",{id:"private-inputs-1"},"Private inputs"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"epoch")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"from_nonce")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"to_nonce")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_nullifier")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"intermediate_user_state_tree_roots")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"old_pos_reps")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"old_neg_reps")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"old_graffities")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"old_sign_ups")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"path_elements")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"attester_ids")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"pos_reps")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"neg_reps")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"graffities")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"overwrite_graffities")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"sign_ups")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"selectors")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"hash_chain_starter"))),(0,a.kt)("h3",{id:"contraints-1"},"Contraints"),(0,a.kt)("h4",{id:"1-verify-blinded-input-user-state"},"1. Verify blinded input user state"),(0,a.kt)("p",null,"Check if"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const input_blinded_user_state = hash(\n    identity_nullifier, \n    intermediate_user_state_tree_roots[0], \n    epoch, \n    from_nonce\n)\n")),(0,a.kt)("h4",{id:"2-verify-attestation-hash-chain"},"2. Verify attestation hash chain"),(0,a.kt)("p",null,"Check if"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const current_hash_chain = hash(\n    hash(\n        attester_ids[i]\n        pos_reps[i],\n        neg_reps[i],\n        graffities[i],\n        sign_ups[i]\n    ),\n    prev_hash_chain\n)\n")),(0,a.kt)("h4",{id:"3-process-attestations-and-update-user-state-tree"},"3. Process attestations and update user state tree"),(0,a.kt)("p",null,"Check ",(0,a.kt)("inlineCode",{parentName:"p"},"intermediate_user_state_tree_roots[i]")," has leaves"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"hash(\n    old_pos_reps[i],\n    old_neg_reps[i],\n    old_graffities[i],\n    old_sign_ups[i]\n)\n")),(0,a.kt)("p",null,"with index ",(0,a.kt)("inlineCode",{parentName:"p"},"attester_ids"),"."),(0,a.kt)("p",null,"And update the leaf by"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"new_pos_reps[i] = pos_reps[i] + old_pos_reps[i]\nnew_neg_reps[i] = neg_reps[i] + old_neg_reps[i]\nif (overwrite_graffities[i]) {\n    new_graffities[i] = graffities[i]\n} else {\n    new_graffities[i] = old_graffities[i]\n}\n    \nnew_sign_ups[i] = sign_ups[i] || old_sign_ups[i]\n")),(0,a.kt)("p",null,"And the new leaf"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"hash(\n    new_pos_reps[i],\n    new_neg_reps[i],\n    new_graffities[i],\n    new_sign_ups[i]\n)\n")),(0,a.kt)("p",null,"Should be one of the leaves in ",(0,a.kt)("inlineCode",{parentName:"p"},"intermediate_user_state_tree_roots[i+1]")," with index ",(0,a.kt)("inlineCode",{parentName:"p"},"attester_ids[i]"),"."),(0,a.kt)("h4",{id:"4-compute-blinded-public-output"},"4. Compute blinded public output"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const output_blinded_user_state = hash(\n    identity_nullifier, \n    intermediate_user_state_tree_roots[n+1], \n    epoch, \n    to_nonce\n)\nconst output_blinded_hash_chain = hash(\n    identity_nullifier, \n    current_hash_chain, \n    epoch, \n    to_nonce\n)\n")),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"See the whole circuit in ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/Unirep/Unirep/blob/v1.0.1/packages/circuits/circuits/processAttestations.circom"},"circuits/processAttestations.circom"))),(0,a.kt)("h2",{id:"3-user-state-transition-proof"},"3. User State Transition proof"),(0,a.kt)("h3",{id:"public-inputs-1"},"Public inputs"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"epoch")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"blinded_user_state")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"blinded_hash_chain_results")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"epoch_tree_root"))),(0,a.kt)("h3",{id:"public-outputs-2"},"Public outputs"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"GST_root")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"new_GST_leaf")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"epoch_key_nullifier"))),(0,a.kt)("h3",{id:"private-inputs-2"},"Private inputs"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"intermediate_user_state_tree_roots")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"start_epoch_key_nonce")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"end_epoch_key_nonce")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_nullifier")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_trapdoor")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"GST_path_elements")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"GST_path_index")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"epk_path_elements")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"hash_chain_results"))),(0,a.kt)("h3",{id:"contraints-2"},"Contraints"),(0,a.kt)("h4",{id:"1-check-if-user-exists-in-the-global-state-tree-1"},"1. Check if user exists in the Global State Tree"),(0,a.kt)("p",null,"Check if ",(0,a.kt)("inlineCode",{parentName:"p"},"hash(identity_commitment, UST_root)")," is one of the leaves in the global state tree of root ",(0,a.kt)("inlineCode",{parentName:"p"},"GST_root"),"."),(0,a.kt)("h4",{id:"2-process-the-hashchain-of-the-epoch-key-specified-by-nonce-n"},"2. Process the hashchain of the epoch key specified by nonce ",(0,a.kt)("inlineCode",{parentName:"h4"},"n")),(0,a.kt)("p",null,"Get all blinded hash chains with nonce iterates from ",(0,a.kt)("inlineCode",{parentName:"p"},"0")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"n-1")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const output_blinded_hash_chain = hash(\n    identity_nullifier, \n    hash_chains[i], \n    epoch, \n    i\n)\n")),(0,a.kt)("p",null,"Seal all hash chains"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const sealed_hash_chain = hash(1, hash_chains[i])\n")),(0,a.kt)("p",null,"Check the epoch tree root with ",(0,a.kt)("inlineCode",{parentName:"p"},"epoch_keys[i]")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"hash_chains[i]"),"."),(0,a.kt)("h4",{id:"3-check-if-blinded-user-state-matches"},"3. Check if blinded user state matches"),(0,a.kt)("p",null,"Output two blinded user states with ",(0,a.kt)("inlineCode",{parentName:"p"},"start_epoch_key_nonce")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"end_epoch_key_nonce"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const output_blinded_user_state[0] = hash(\n    identity_nullifier, \n    intermediate_user_state_tree_roots[0], \n    epoch, \n    start_epoch_key_nonce\n)\nconst output_blinded_user_state[1] = hash(\n    identity_nullifier, \n    intermediate_user_state_tree_roots[1], \n    epoch, \n    end_epoch_key_nonce\n)\n")),(0,a.kt)("h4",{id:"4-compute-and-output-nullifiers-and-new-gst-leaf"},"4. Compute and output nullifiers and new GST leaf"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const new_GST_leaf = hash(\n    id_commitment, \n    intermediate_user_state_tree_roots[1]\n)\n")),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"See the whole circuit in ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/Unirep/Unirep/blob/v1.0.1/packages/circuits/circuits/userStateTransition.circom"},"circuits/userStateTransition.circom"))))}h.isMDXComponent=!0}}]);